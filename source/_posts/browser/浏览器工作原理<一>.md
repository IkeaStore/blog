---
title: 浏览器工作原理《一》
date: 2020-05-24 20:00:00
tags: 
- browser
- macrotask
- microtask
---

## 前言
最近复习了下浏览器的工作原理和一些知识，所以想着对此作一些小小的总结出一系列的文章，本篇先梳理进程和线程以及任务的一些总结，先大概的知道浏览器的运行流程

<!-- more -->

#### 概念

启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

而线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率



#### 进程和线程之间的几个特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃

- 线程之间共享进程中的数据

- 当一个进程关闭之后，操作系统会回收进程所占用的内存

- 进程之间的内容相互隔离



#### 浏览器是多进程的，一个浏览器主要包含以下几种进程：

- Browser主进程

  主要负责界面显示、用户交互、子进程管理，同时提供存储等功能

- 第三方插件进程

  主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

- GPU进程

  其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

- 渲染进程

  核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- 网络进程

  主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程，主要面向渲染进程和浏览器进程等提供网络下载功能。

#### 基于以上浏览器的几个主要进程，对于前端来说，重点需要掌握的是渲染进程，一个渲染进程包含了以下几个主要线程

- GUI渲染线程
- JS引擎线程
- 事件触发线程
- 定时触发器线程
- 异步http请求线程

#### 任务执行的几个结论

- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，为一个执行栈
- 主线程之外，事件触发现场管理着一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕，系统才读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

#### 宏任务（macrotask）和微任务（microtask）

##### 定义：

宿主发起的任务称为宏任务，就是指消息队列中的等待被主线程执行的事件；JavaScript 引擎发起的任务称为微观任务，可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前；在ECMAScript中，microtask称为jobs，macrotask可称为task

##### 执行机制

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程如果遇到微任务，将将它添加到微任务的任务队列里
- 宏任务执行完毕后，立即执行当前微任务队列里所有的微任务
- 当前宏任务执行完毕，开始检测渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务

##### 一点总结

- 如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张；
- 和异步调用不同，微任务依然会在**当前任务执行结束之前**被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。
