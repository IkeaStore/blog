---
title: Chrome V8引擎的内存回收机制浅析
date: 2019-12-11
tags: V8
---

我们知道JavaScript有它自己的一套内存管理机制，内存回收存在的主要目的是可以大幅简化程序的内存管理代码，减少由于程序长时间运行产生的内存泄漏问题，但是我们无法手动操作和干预内存回收。
但了解内存回收的机制是很有必要的（说不定啥时候就被别人问到了呢？）

<!-- more -->

# 一：V8的内存限制

对于非JavaScript的后端语言来说，对内存的使用没有太大的限制，但是JavaScript不同，V8引擎只能使用系统的一部分内存：

* 64位操作系统 - 1.4G(Max)
* 32位操作系统 - 0.7G(Max)

虽然对于前端来说，对大内存的操作需求其实并不是很大，但是对后端语言来说就不是这样了，形如Node.js，当我们需要读取一个好几G的文件的时候，就不能全部将它读入内存了。

那到这里问题就来了，肯定有人会问，为什么只给V8引擎分配这么一点的内存空间呢？其实这里主要有两个原因，且其原因和JavaScript的语言特性紧密相关：

1. JavaScript的单线程执行机制：这意味着一旦线程开始了内存回收，那其他的运行逻辑都必须暂停。
2. JavaScript内存回收机制的限制：V8官方的形容是这样的：以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要 1s 以上。

说明对于V8引擎来说，内存回收其实是一个非常消耗时间的操作。并且在这么长的时间里，JS代码会一直无响应，从而造成应用卡顿，导致程序的性能下降。所以V8做了这样一个限制堆内存的简单粗暴的权衡手段（毕竟前端比较少碰到操作好几个G内存的场景）。

但是呢我们也可以自己手动调整内存的限制，由于V8把堆内存分成了两部分进行处理：`新生代内存`和`老生代内存`，所以配置的时候也是需要分开配置的，具体配置如下：

```js
// 调整新生代内存，单位KB
node --max-new-space-size=2048 xxx.js
```

```js
 // 调整老生代内存，单位MB
node --max-old-space-size=2048 xxx.js 
```

# 二：堆内存分类

V8把堆内存分成了两部分进行处理：`新生代内存`和`老生代内存`，这两个内存之和就是V8的堆内存大小。
新生代内存：临时分配的内存，存活时间短
老生代内存：常驻内存，存活时间长

     —————————————————————————————————————
    |   新生代  ｜          老生代          ｜
     —————————————————————————————————————

所以根据这两种不同的堆内存，V8使用了不同的回收策略。

# 三：新生代内存的回收

 新生代的内存在64位系统下的默认内存限制是32MB，在32位系统下是16MB，这么小的原因是因为新生代中的变量存活时间短，用了马上就被回收了，不容易产生太大的内存负担，因此可以将它设的足够小。

 那么问题来啦，新生代的内存回收是怎样的过程呢？
 首先需要将新生代的内存空间一分为二：

     —————————————————————
    |   From  ｜    To    ｜
     —————————————————————

 其中`From`部分表示正在使用的内存，`To`是目前闲置的内存，当进行内存回收时，V8将`From`部分的对象检查一遍，如果是存活对象，那么复制到`To`内存中(在`To`内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。

 当所有的`From`中的存活对象按照顺序进入到To内存之后，`From` 和 `To` 两者的角色对调，From现在被闲置，`To`为正在使用，如此循环。

 那么这里肯定会有一个疑问，把非存活对象直接回收了就好了，为什么还要进行后面的等对调循环操作呢？

 是这样的，对象在`To`内存中按照顺序从头放置的，是因为在内存的使用过程中可能会有这样的场景：

     —————————————————————
    | X    X           X  ｜
    |    X         X      ｜
    |                 X   ｜
    |  X          X       ｜
     —————————————————————

 其中X表示的是存活对象。空白的部分表示的是待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做内存碎片。
 而刚刚说的新生代内存回收算法也叫Scavenge算法。Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:
    
     —————————————————————
    | XXXXXXX             ｜
    |                     ｜
    |                     ｜
    |                     ｜
     —————————————————————

 这样的话，就很好的方便了后续连续空间的分配，不过显然的是，Scavenge算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。


# 四：老生代内存的回收

 刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫`晋升`。

 发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:

 * 已经经历过一次 Scavenge 回收。
 * To（闲置）空间的内存空余不足75%。

 那么现在来了解下老生代的内存回收机制，老生代中累积的变量空间一般都是很大的，当然不能用Scavenge算法啦。所以老生代的是如何进行内存回收的呢？
 1. 进行标记-清除。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。
 当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代也是一样会进行第二步的内存整理。
 2. 整理内存碎片。在清除阶段结束后，把存活的对象全部往一端靠拢。

# 五：增量标记

 由于JS的单线程机制，V8 在进行内存回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的内存回收任务很重，那么耗时会非常长，严重影响应用的性能。
 为了避免这样问题，V8 采取了增量标记的方案，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"休息"一下，让js应用逻辑执行一会儿。
 然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。
 经过增量标记之后，内存回收过程对JS应用的阻塞时间减少到原来的1/6, 可以看到，这是一个非常成功的改进。


到这里V8的内存回收机制就大概解释清啦，算是一个比较简单的概念理解～
